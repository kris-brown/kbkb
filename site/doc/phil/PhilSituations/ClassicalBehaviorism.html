<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8"/>
  <meta content="pandoc" name="generator"/>
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
  <title>Classical Behaviorism</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 80em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

<!-- Summary stuff here -->
<script type="text/javascript">
	(function()
	{
		//basic html5 shim just for the elements we're using
		for(var tags = ['nav','details','summary'], i = 0; i < tags.length; i ++)
		{
			document.createElement(tags[i]);
		}
	})();
	</script>

	<link rel="stylesheet" href="https://web.stanford.edu/~ksb/phil/demo.css" type="text/css" media="screen, projection, print, handheld" />

    <!-- MiniPreview stuff here -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <link href="https://web.stanford.edu/~ksb/phil/jquery.minipreview.css" rel="stylesheet">
    <script src="https://web.stanford.edu/~ksb/phil/jquery.minipreview.js"></script>
    <script>
        $(function() {
          $('a').miniPreview({ prefetch: 'parenthover' }); // ALL links
		  // none, parenthover, or pageload
          //$('#p4 a').miniPreview({ prefetch: 'none' });
        });
    </script>
</head><body><header id="title-block-header">
<h1 class="title">Classical Behaviorism</h1>
</header><p><a href="https://web.stanford.edu/~ksb/phil/doc/phil/PhilSituations/ChildrensGame.html">Previous</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/PhilSituations.html">Up</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/PhilSituations/MontaigneDog.html">Next</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/PhilSituations/ClassicalBehaviorism.pdf">PDF</a></p><p>This is related to the problem of: suppose you follow a rule. You use a representation of that rule to train the next generation to follow the rule. How do we know that the same rule is being passed on? Isn’t it like a game of telephone, given the ambiguity of following rules (gerrymandering problem - you have a rule in your head and punish me for lifting the glass of water, but I interpret this as punishment for lifting my arm or one of a million other possible explanations). Brandom’s response:</p><p>Well, maybe so and maybe it a given rule isn’t as stable as we think. I mean, it’s only if it had enough coherence and enough stability, that we’re here. (Anthropomorphic principle). And when Wittgenstein harps on this, you know, unless as a matter of fact, we tended to go on the same way when trained the same way, to a remarkable extent, we wouldn’t get a language game off the ground.</p><p>I should mention that this gerrymandering issue is what was wrong with classical behaviorism from an empirical point of view. <a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> Remember, the stimulus and response were supposed to be objective features of the critters you were looking at. So that the behavioral scientist modeled on the natural scientist, her own conceptual scheme was not supposed to be involved in characterizing the behavior of these critters. But if you ask sort of classical studies, so I take the rat, and set him down four steps away from the bar, and train him, then if he walks four steps forward and presses down on the bar, he’ll get a rat yummy. And that stimulus, let’s say, the light goes on, walks, four steps, pushes down on the bar gets a rat yummy. We indoctrinate him with that, conditioned learning, he can do that. And now we ask the behavioral scientist. And now if I put in eight steps away from the bar, what do you predict he’s going to do? Is he going to go four steps forward and move his paw up and down? Is that the behavior that has been associated with the stimulus? Or would you predict that he’ll go eight steps forward and press down on the bar. That is, the right description is that he’ll go from where he is to the bar and press on the bar? Well, the minute you think about this, you realize that we can gerrymander, what he was taught, there are many descriptions, that that are available to us for what he was taught. And in fact, no one who works with the animals would expect him to move four steps forward, and not be pressing on the bar. But why is that? Is that something that you without importing any understanding of this are objectively reading off of the situation? Or have you, in fact, all along been importing, your characterization of what the regularity is that you are, that you’re characterizing? This is actually empirical as well a methodological problem. What is the prediction that you’re supposed to make at this point? And how do you justify the one rather than rather than the other by your methodological lights?</p><section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>What was wrong with classical behaviorism, from a <em>conceptual</em> point of view, is we can see it with the wisdom of hindsight is just a larval stage on the way to functionalism. As all of the considerations that lead people to think have direct stimulus response connections, are satisfied still, if you allow intervening states. It’s still an empirical undertaking, and so on. But there’s a lot more formal power, you can get Turing machines, if you can get functional states, so you can get a lot farther. That’s why nobody should be a classical behaviorist anymore: be a functionalist, you get all the advantages, and a lot more expressive power.<a class="footnote-back" href="#fnref1" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
	<script type="text/javascript">
        (function()
        {

            //we'll need the getBoundingClientRect function for the
            //hash scripting, so if it's not supported just return,
            //then the elements will remain in their default open state
            if(typeof(document.createElement('span').getBoundingClientRect) == 'undefined') { return; }


            //add event construct for modern browsers or IE
            //which fires the callback with a pre-converted target reference
            function addEvent(node, type, callback)
            {
                if(node.addEventListener)
                {
                    node.addEventListener(type, function(e)
                    {
                        callback(e, e.target);

                    }, false);
                }
                else if(node.attachEvent)
                {
                    node.attachEvent('on' + type, function(e)
                    {
                        callback(e, e.srcElement);
                    });
                }
            }

            //handle cross-modal click events
            function addClickEvent(node, callback)
            {
                var keydown = false;
                addEvent(node, 'keydown', function()
                {
                    keydown = true;
                });
                addEvent(node, 'keyup', function(e, target)
                {
                    keydown = false;
                    if(e.keyCode == 13) { callback(e, target); }
                });
                addEvent(node, 'click', function(e, target)
                {
                    if(!keydown) { callback(e, target); }
                });
            }

            //get the nearest ancestor element of a node that matches a given tag name
            function getAncestor(node, match)
            {
                do
                {
                    if(!node || node.nodeName.toLowerCase() == match)
                    {
                        break;
                    }
                }
                while(node = node.parentNode);

                return node;
            }



            //create a started flag so we can prevent the initialisation
            //function firing from both DOMContentLoaded and window.onloiad
            var started = false;

            //initialisation function
            function addDetailsOmnifill(list)
            {
                //if this has already happened, just return
                //else set the flag so it doesn't happen again
                if(started)
                {
                    return;
                }
                started = true;

                //get the collection of details elements, but if that's empty
                //then we don't need to bother with the rest of the scripting
                if((list = document.getElementsByTagName('details')).length == 0)
                {
                    return;
                }

                //else iterate through them to apply their initial state
                for(var n = list.length, i = 0; i < n; i ++)
                {
                    var details = list[i];

                    //detect native implementations
                    details.__native = typeof(details.open) == 'boolean';

                    //save shortcuts to the inner summary and content elements
                    details.__summary = details.getElementsByTagName('summary').item(0);
                    details.__content = details.getElementsByTagName('div').item(0);

                    //if the content doesn't have an ID, assign it one now
                    //which we'll need for the summary's aria-controls assignment
                    if(!details.__content.id)
                    {
                        details.__content.id = 'details-content-' + i;
                    }

                    //then define aria-controls on the summary to point to that ID
                    //so that assistive technologies know it controls the aria-expanded state
                    details.__summary.setAttribute('aria-controls', details.__content.id);

                    //also set tabindex so the summary is keyboard accessible
                    details.__summary.setAttribute('tabindex', '0');

                    //then set aria-expanded and style.display and remove the
                    //open attribute, so this region is now collapsed by default
                    details.__content.setAttribute('aria-expanded', 'false');
                    details.__content.style.display = 'none';
                    details.removeAttribute('open');

                    //create a circular reference from the summary back to its
                    //parent details element, for convenience in the click handler
                    details.__summary.__details = details;

                    //then if this is not a native implementation, create a twisty
                    //inside the summary, saving its reference as a summary property
                    if(!details.__native)
                    {
                        var twisty = document.createElement('span');
                        twisty.className = 'twisty';
                        twisty.appendChild(document.createTextNode('\u25ba'));

                        details.__summary.__twisty = details.__summary.insertBefore(twisty, details.__summary.firstChild);
                    }
                }



                //define a statechange function that updates aria-expanded and style.display
                //to either expand or collapse the region (ie. invert the current state)
                //or to set a specific state if the expanded flag is strictly true or false
                //then update the twisty if we have one with a correpsonding glyph
                function statechange(summary, expanded)
                {
                    if(typeof(expanded) == 'undefined')
                    {
                        expanded = summary.__details.__content.getAttribute('aria-expanded') == 'true';
                    }
                    else if(expanded === false)
                    {
                        summary.__details.setAttribute('open', 'open');
                    }
                    else if(expanded === true)
                    {
                        summary.__details.removeAttribute('open');
                    }

                    summary.__details.__content.setAttribute('aria-expanded', (expanded ? 'false' : 'true'));
                    summary.__details.__content.style.display = (expanded ? 'none' : 'block');

                    if(summary.__twisty)
                    {
                        summary.__twisty.firstChild.nodeValue = (expanded ? '\u25ba' : '\u25bc');
                    }

                    return true;
                }

                //now bind a document click event to handle summary elements
                //if the target is not inside a summary element, just return true
                //to pass-through the event, else call and return the statechange function
                //which also returns true to pass-through the remaining event
                addClickEvent(document, function(e, summary)
                {
                    if(!(summary = getAncestor(summary, 'summary')))
                    {
                        return true;
                    }
                    return statechange(summary);
                });



                //define an autostate function that identifies whether a target
                //is or is inside a details region, and if so expand that region
                //then iterate up the DOM expanding any ancestors, then finally
                //return the original target if applicable, or null if not
                function autostate(target, expanded, ancestor)
                {
                    if(typeof(ancestor) == 'undefined')
                    {
                        if(!(target = getAncestor(target, 'details')))
                        {
                            return null;
                        }
                        ancestor = target;
                    }
                    else
                    {
                        if(!(ancestor = getAncestor(ancestor, 'details')))
                        {
                            return target;
                        }
                    }

                    statechange(ancestor.__summary, expanded);

                    return autostate(target, expanded, ancestor.parentNode);
                }

                //then if we have a location hash, call the autostate
                //function now with the target element it refers to
                if(location.hash)
                {
                    autostate(document.getElementById(location.hash.substr(1)), false);
                }

                //then bind a document click event to handle internal page links
                //ignoring links to other pages, else passing the target it
                //refers to to the autostate function, and if that returns a target
                //auto-scroll the page so that the browser jumps to that target
                //then return true anyway so that the address-bar hash updates
                addEvent(document, 'click', function(e, target)
                {
                    if(!target.href)
                    {
                        return true;
                    }
                    if((target = target.href.split('#')).length == 1)
                    {
                        return true;
                    }
                    if(document.location.href.split('#')[0] != target[0])
                    {
                        return true;
                    }
                    if(target = autostate(document.getElementById(target[1]), false))
                    {
                        window.scrollBy(0, target.getBoundingClientRect().top);
                    }
                    return true;
                });
            }

            //then bind two load events for modern and older browsers
            //if the first one fires it will set a flag to block the second one
            //but if it's not supported then the second one will fire
            addEvent(document, 'DOMContentLoaded', addDetailsOmnifill);
            addEvent(window, 'load', addDetailsOmnifill);

        })();
        </script>
 </body></html>