<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8"/>
  <meta content="pandoc" name="generator"/>
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
  <title>Inference and Meaning</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 80em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"/></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

<!-- Summary stuff here -->
<script type="text/javascript">
	(function()
	{
		//basic html5 shim just for the elements we're using
		for(var tags = ['nav','details','summary'], i = 0; i < tags.length; i ++)
		{
			document.createElement(tags[i]);
		}
	})();
	</script>

	<link rel="stylesheet" href="https://web.stanford.edu/~ksb/phil/demo.css" type="text/css" media="screen, projection, print, handheld" />

    <!-- MiniPreview stuff here -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <link href="https://web.stanford.edu/~ksb/phil/jquery.minipreview.css" rel="stylesheet">
    <script src="https://web.stanford.edu/~ksb/phil/jquery.minipreview.js"></script>
    <script>
        $(function() {
          $('a').miniPreview({ prefetch: 'parenthover' }); // ALL links
		  // none, parenthover, or pageload
          //$('#p4 a').miniPreview({ prefetch: 'none' });
        });
    </script>
</head><body><header id="title-block-header">
<h1 class="title">Inference and Meaning</h1>
</header><p><a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02/PhilofLogicAside.html">Previous</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02.html">Up</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02/SomeReflectionsonLanguageGames.html">Next</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02/InferenceandMeaning.pdf">PDF</a></p><p>A main argument of <em>Inference and Meaning</em> (cite) is that any language that makes essential use of non-logical, descriptive vocabulary must be understand as having that vocabulary standing in materially good (rather than just logically good) inferences.</p><p>“Concepts as Involving Laws and inconceivable without them” is the title of an unintelligible essay by Sellars (but the title is the thesis and intelligible).</p><p>Sellars answers the first major question by claiming logical vocabulary (more specifically, alethic modal vocabulary, about what’s necessary and what’s possible) has the expressive job of making explicit the material proprieties of inference that articulate the content of non-logical concepts. Frege is more explicit about this (that you can use this to distinguish logical vocabulary) than Sellars.</p><p>Dan Dennett argues that we have to take animals as grasping modus ponens because they treat some inferences as good and others as bad (see <span class="math inline">\(\ref{phil-scenarios-section-dog-disjunction}\)</span>). You could make explicit the practical capacity the animal has using a statement of disjunctive syllogism, but Sellars would ask what is the surplus value of invoking that explicit expression? (Over simply describing what is the dog can do).</p><p>There have to be some practical moves you’re just allowed to make without them having to take the form of explicit premises (see <span class="math inline">\(\ref{phil-problems-section-tortoise}\)</span>). Sellars touches upon this in Reflections on Language Games. He talks about free/auxillary positions that you’re always allowed to occupy. We could have the auxillary position <span class="math inline">\(\forall x, \psi(x)\vdash \phi(x)\)</span> which would license us to move from a position <span class="math inline">\(\psi(a)\)</span> to a position <span class="math inline">\(\phi(a)\)</span>, but we could also encode this with position for each possible move (<span class="math inline">\(\psi(a)\vdash \phi(a)\)</span>, <span class="math inline">\(\psi(b)\vdash\phi(b)\)</span>, ...). He ways that we could imagine replacing positions with moves, but it’s not possible to imagine all moves being replaced with positions (‘a game without moves is Hamlet without the Prince of Denmark’).</p><p>Sellars is addressing tradition that wants some small set of explicit principles in accordance with which to reason. Any inference you think is good that isn’t derivable from that small set of principles (e.g. modus ponens) is actually an infamy (has some suppressed premises). This is early analytic philosophy’s embrace of the new logic. Sellar’s contrary view (radical at the time) is that actually the reasoning could be completely in order, just with material proprieties of reasoning. You can still give/ask for reasons and mean that <span class="math inline">\(p\)</span>, but what the logic does is give you meta-linguistic control to talk about what is a good inference and say that <span class="math inline">\(p \vdash q\)</span> is a good inference. Sellars doesn’t extrapolate from this that logic is an optional superstructure in our lives - we need to be able to think and talk about the goodness of inferences.</p><p>Brandom: logic is the organ of semantic self-consciousness. The set of concepts that lets us bring our endorsement of some inferences as good/bad (this endorsement as something that reasons can be given or asked for) into the game of giving/asking for reasons.</p><p>Example: <span class="math inline">\(A\vdash B\)</span> where <span class="math inline">\(A\)</span> is “she asked me to hand her the dish towel&#34; and <span class="math inline">\(B\)</span> is “I shall hand her the dish towel”. Traditional analytic philosophy will call this an infamy since it does not explicitly state how her request engages my motivational structure. Sellars would want to say that this invocation of the desire makes explicit the endorsement of <span class="math inline">\(A \vdash B\)</span> rather than referring to some item of the world.</p><p>Sellars complains about Carnap treating logical consequence as a syntactically definable relation between sentences. Just writing down the rules under a heading ‘rules’ instead of ‘axioms’ isn’t making explicit the normative force they have (it leaves out the rulishness - that a rule is a rule for <em>doing</em> something). This is a subtle point that doesn’t matter for many purposes, but Sellars believes it’s important if you want to understand what’s going on with reasoning.</p><p>Potential counterargument against sellars: subjunctive conditionals are not making explicit proprieties of inference, but in fact are descriptions about possible worlds. To address this, we note there are separate issues. Firstly, there’s the question about whether it’s intelligible to have descriptive vocabulary in play in a context where there’s no counterfactual reasoning. E.g. Hume believes he understands empirical facts perfectly well (the cat is on the mat) but not statements about what’s possible and necessary. But Kant saw that this isn’t intelligble - you need to make a distinction about what’s possible with the cat and what’s not (it’s possible for the cat to not be on the mat, but not possible for it to be larger than the sun) or else there’s nothing you could say about the conctent of the concept of ‘cat’ that I’ve got (it would be just a label). The second issue is the codifiability of proprieties of material inference by logical vocabulary: whether a possible worlds analysis is incompatible with seeing subjunctive conditionals as making properties of inference explicit. Sellars would like to see a possible worlds analysis that matches up.</p><p>“There’s an important difference between logical / modal / normative predicates on the one hand, and such predicates as ‘red’ on the other.” There’s nothing to the formal except their role in reasoning, indeed, their role and make as meta linguistics sort of making explicit something about the ground level. For the latter, he wants to argue that these predicates too are meaningful insofar as their role in reasoning, but it’s less obvious.</p><p>“Red is a quality”. This conveys the same information as the syntactical sentence “<em>Red</em> is a one place predicate.” <span class="math inline">\(\ref{phil-quotes-section-modalities-and-norms}\)</span>. What you’re doing in asserting that premise from which to reason (couched in modal vocabulary) is endorsing a principle in accordance with which to reason (couched in normative vocabulary).</p><p>We cannot completely identify modal and normative statements. When I say &#34;copper melts at 1084 degrees&#34; one makes a claim that is true even if ther were no reasoners (so it can’t be a claim directly <em>about</em> inferences being good). What it <em>conveys</em> is about inferences, not what it <em>says</em>. Likewise, I say “The sun is shining” while I convey “I believe the sun is shining.”</p><p>It might help to make progress toward understanding the say/convey distinction (which Sellars admits he’s not clear about) by distinguishing two flavors of inference:</p><ol>
<li><p>semantic inference: good in virtue of the contents of the premises and the conclusion</p></li>
<li><p>pragmatic inference: good in virtue of what you’re doing in asserting the premises or the conclusion.</p>
<ul>
<li><p>e.g. John says ‘your book is terrible’ and I infer that he’s mad at me</p></li>
<li><p>Geech embedding distinction between the two: we look at whether we’d endorse “My book is terrible, then John is mad at me&#34;. Because we wouldn’t, we know the inference is pragmatic.</p></li>
</ul></li>
</ol>
	<script type="text/javascript">
        (function()
        {

            //we'll need the getBoundingClientRect function for the
            //hash scripting, so if it's not supported just return,
            //then the elements will remain in their default open state
            if(typeof(document.createElement('span').getBoundingClientRect) == 'undefined') { return; }


            //add event construct for modern browsers or IE
            //which fires the callback with a pre-converted target reference
            function addEvent(node, type, callback)
            {
                if(node.addEventListener)
                {
                    node.addEventListener(type, function(e)
                    {
                        callback(e, e.target);

                    }, false);
                }
                else if(node.attachEvent)
                {
                    node.attachEvent('on' + type, function(e)
                    {
                        callback(e, e.srcElement);
                    });
                }
            }

            //handle cross-modal click events
            function addClickEvent(node, callback)
            {
                var keydown = false;
                addEvent(node, 'keydown', function()
                {
                    keydown = true;
                });
                addEvent(node, 'keyup', function(e, target)
                {
                    keydown = false;
                    if(e.keyCode == 13) { callback(e, target); }
                });
                addEvent(node, 'click', function(e, target)
                {
                    if(!keydown) { callback(e, target); }
                });
            }

            //get the nearest ancestor element of a node that matches a given tag name
            function getAncestor(node, match)
            {
                do
                {
                    if(!node || node.nodeName.toLowerCase() == match)
                    {
                        break;
                    }
                }
                while(node = node.parentNode);

                return node;
            }



            //create a started flag so we can prevent the initialisation
            //function firing from both DOMContentLoaded and window.onloiad
            var started = false;

            //initialisation function
            function addDetailsOmnifill(list)
            {
                //if this has already happened, just return
                //else set the flag so it doesn't happen again
                if(started)
                {
                    return;
                }
                started = true;

                //get the collection of details elements, but if that's empty
                //then we don't need to bother with the rest of the scripting
                if((list = document.getElementsByTagName('details')).length == 0)
                {
                    return;
                }

                //else iterate through them to apply their initial state
                for(var n = list.length, i = 0; i < n; i ++)
                {
                    var details = list[i];

                    //detect native implementations
                    details.__native = typeof(details.open) == 'boolean';

                    //save shortcuts to the inner summary and content elements
                    details.__summary = details.getElementsByTagName('summary').item(0);
                    details.__content = details.getElementsByTagName('div').item(0);

                    //if the content doesn't have an ID, assign it one now
                    //which we'll need for the summary's aria-controls assignment
                    if(!details.__content.id)
                    {
                        details.__content.id = 'details-content-' + i;
                    }

                    //then define aria-controls on the summary to point to that ID
                    //so that assistive technologies know it controls the aria-expanded state
                    details.__summary.setAttribute('aria-controls', details.__content.id);

                    //also set tabindex so the summary is keyboard accessible
                    details.__summary.setAttribute('tabindex', '0');

                    //then set aria-expanded and style.display and remove the
                    //open attribute, so this region is now collapsed by default
                    details.__content.setAttribute('aria-expanded', 'false');
                    details.__content.style.display = 'none';
                    details.removeAttribute('open');

                    //create a circular reference from the summary back to its
                    //parent details element, for convenience in the click handler
                    details.__summary.__details = details;

                    //then if this is not a native implementation, create a twisty
                    //inside the summary, saving its reference as a summary property
                    if(!details.__native)
                    {
                        var twisty = document.createElement('span');
                        twisty.className = 'twisty';
                        twisty.appendChild(document.createTextNode('\u25ba'));

                        details.__summary.__twisty = details.__summary.insertBefore(twisty, details.__summary.firstChild);
                    }
                }



                //define a statechange function that updates aria-expanded and style.display
                //to either expand or collapse the region (ie. invert the current state)
                //or to set a specific state if the expanded flag is strictly true or false
                //then update the twisty if we have one with a correpsonding glyph
                function statechange(summary, expanded)
                {
                    if(typeof(expanded) == 'undefined')
                    {
                        expanded = summary.__details.__content.getAttribute('aria-expanded') == 'true';
                    }
                    else if(expanded === false)
                    {
                        summary.__details.setAttribute('open', 'open');
                    }
                    else if(expanded === true)
                    {
                        summary.__details.removeAttribute('open');
                    }

                    summary.__details.__content.setAttribute('aria-expanded', (expanded ? 'false' : 'true'));
                    summary.__details.__content.style.display = (expanded ? 'none' : 'block');

                    if(summary.__twisty)
                    {
                        summary.__twisty.firstChild.nodeValue = (expanded ? '\u25ba' : '\u25bc');
                    }

                    return true;
                }

                //now bind a document click event to handle summary elements
                //if the target is not inside a summary element, just return true
                //to pass-through the event, else call and return the statechange function
                //which also returns true to pass-through the remaining event
                addClickEvent(document, function(e, summary)
                {
                    if(!(summary = getAncestor(summary, 'summary')))
                    {
                        return true;
                    }
                    return statechange(summary);
                });



                //define an autostate function that identifies whether a target
                //is or is inside a details region, and if so expand that region
                //then iterate up the DOM expanding any ancestors, then finally
                //return the original target if applicable, or null if not
                function autostate(target, expanded, ancestor)
                {
                    if(typeof(ancestor) == 'undefined')
                    {
                        if(!(target = getAncestor(target, 'details')))
                        {
                            return null;
                        }
                        ancestor = target;
                    }
                    else
                    {
                        if(!(ancestor = getAncestor(ancestor, 'details')))
                        {
                            return target;
                        }
                    }

                    statechange(ancestor.__summary, expanded);

                    return autostate(target, expanded, ancestor.parentNode);
                }

                //then if we have a location hash, call the autostate
                //function now with the target element it refers to
                if(location.hash)
                {
                    autostate(document.getElementById(location.hash.substr(1)), false);
                }

                //then bind a document click event to handle internal page links
                //ignoring links to other pages, else passing the target it
                //refers to to the autostate function, and if that returns a target
                //auto-scroll the page so that the browser jumps to that target
                //then return true anyway so that the address-bar hash updates
                addEvent(document, 'click', function(e, target)
                {
                    if(!target.href)
                    {
                        return true;
                    }
                    if((target = target.href.split('#')).length == 1)
                    {
                        return true;
                    }
                    if(document.location.href.split('#')[0] != target[0])
                    {
                        return true;
                    }
                    if(target = autostate(document.getElementById(target[1]), false))
                    {
                        window.scrollBy(0, target.getBoundingClientRect().top);
                    }
                    return true;
                });
            }

            //then bind two load events for modern and older browsers
            //if the first one fires it will set a flag to block the second one
            //but if it's not supported then the second one will fire
            addEvent(document, 'DOMContentLoaded', addDetailsOmnifill);
            addEvent(window, 'load', addDetailsOmnifill);

        })();
        </script>
 </body></html>