<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8"/>
  <meta content="pandoc" name="generator"/>
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
  <title>Some Reflections on Language Games</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 80em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"/></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

<!-- Summary stuff here -->
<script type="text/javascript">
	(function()
	{
		//basic html5 shim just for the elements we're using
		for(var tags = ['nav','details','summary'], i = 0; i < tags.length; i ++)
		{
			document.createElement(tags[i]);
		}
	})();
	</script>

	<link rel="stylesheet" href="https://web.stanford.edu/~ksb/phil/demo.css" type="text/css" media="screen, projection, print, handheld" />

    <!-- MiniPreview stuff here -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <link href="https://web.stanford.edu/~ksb/phil/jquery.minipreview.css" rel="stylesheet">
    <script src="https://web.stanford.edu/~ksb/phil/jquery.minipreview.js"></script>
    <script>
        $(function() {
          $('a').miniPreview({ prefetch: 'parenthover' }); // ALL links
		  // none, parenthover, or pageload
          //$('#p4 a').miniPreview({ prefetch: 'none' });
        });
    </script>
</head><body><header id="title-block-header">
<h1 class="title">Some Reflections on Language Games</h1>
</header><p><a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02/InferenceandMeaning.html">Previous</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02.html">Up</a></p><p><a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Brandom/OnSellars/2009/Lecture02/SomeReflectionsonLanguageGames.pdf">PDF</a></p><p>Regulism (conceptual norms as a matter of explicit rules) vs regularism (norms in terms of actual regularities). These are identified with empiricist and rationalist approaches. (Kris: I also see prescriptivism and descriptivism in linguistics)</p><p>One purpose: “I shall have a chief my present purpose if I’ve made plausible the idea that an organism might come to play a language game, that is to move from position to position, the system of moves and positions, and to do it because of the system without having to obey rules, and hence without having to be playing a meta language game.” (Section 18)</p><p>He doesn’t explicitly mention Wittgenstein (<span class="math inline">\(\ref{jokes-subsection-worst-philosopher}\)</span>). (Other times he uses astrices to censor his name). Thinking about language in terms of rules is Kantian. His notion of norms was juridical/jurisprudential. A rule that enjoins the doing of an action A is a sentence in some language, which requires more rules to interpret (regress - how do we deal with it?). Kant identified this regress (A132/B171) - “judgment is a peculiar talent that can be practiced only and not taught”. Which is using distinction between things that can be shown (by examples) vs taught. Wittgenstein addresses this regress in the late 100’s of PI.</p><p>Rejecting mere conformity: If we just consider conforming to a rule rather than obeying a rule, there’s no regress, but we lose the normativity.</p><p>“[Mere conformity people] claim that it’s raining therefore the streets will be wet (when it isn’t an infamatic abridgement of a formally valid argument) is merely the manifestation of a tendency to expect to see the wet streets when one finds it’s raining. In this latter case, it’s a manifestation of a process which at best can only simulate inference, since it’s a habitual transition, and as such not governed by a principle or rule by reference to which can be characterized as valid or invalid. That Hume dignified the activation of an association with the phrase ‘causal inference’ is about a minor flaw, they continue, in an otherwise brilliant analysis. It should, however, be immediately pointed out that before one has a right to say that what Hume calls ‘causal inference’ really is an inference at all, but merely a habitual transition from one thought to another. And contrast that with in this context, the genuine logical inferences which are, one must pay the price of showing just how logical inference is something more than a mere habitual transition empiricists in the human tradition have rarely paid this price, a fact which is proved most unfortunate for the following reason. An examination of the history of the subject shows that those who have held that causal inference only simulates inference proper have been led to do so as a result of the conviction that if it were a genuine inference, the laws of nature, things that govern this would be discovered to us by pure reason. As they’re thinking of what’s a good inference having to be something that’s transparent merely by introspection in the way that the laws of logic are.” (him making point about distinction of real inferences and mere associations. )</p><p>No distinction between correct and incorrect can be made by purely pointing to regularity - as Wittgenstein pointed out, you’ll always find some regularity (there’s some elegant rule that generates the sequence, for any arbitrary sequence). This is also called ‘disjunctiv-itis’ or ‘gerrymandering objections’. After a debate between Dretsky and Fodor: we’re trying to see what makes the word porcupine mean porcupine. When ‘porcupine’ is used in an observational way, it’s typically in response to porcupines. So can we use that regularity to understand what ‘porcupine’ means? No, because of counterfactuals. If it happened that the porcupines we saw were almost always male, would the word mean male porcupine? Or if we look at dispositions, if they’re disposed to also call echidnas porcupines (that’s the disjunction), why not say that ‘porcupine’ means porcupine or echidna?</p><p>“what’s denied is the playing a game logically involves obedience to the rules of the game. And hence the ability to use the language to play the language game in which the rules are formulated.” (page 29) Need a sense of playing the game stronger than conforming but weaker than having the rules in mind.</p><p>Metaphysicus suggests why not a non-linguistic awareness of the rules? This is its own regress.</p><p>“We’ve tacitly accepted so far and the dialectic dichotomy between merely conforming to the rules and obey. But surely this is a false dichotomy. Is there something in between, for it required us to suppose that the only way in which a complex system of activity can be involved in the explanation of the occurrence of a particular act is by the agent explicitly envisaging the system and intending its realization. And that’s as much as to say that unless the agent conceives of the system, the conformity of his behavior to the system must be accidental. ” So what’s needed he’s saying, is going to be something that says, look, there’s an explanation of why he conforms to the rules. That invokes the rules, but it doesn’t invoke them by him being aware of them. One example of this is teleosemantics <span class="math inline">\(\ref{phil-situations-section-bee-waggles}\)</span>.</p><p>The essential thing for Kant was a distinction between what was between acting according to a rule and acting according to a conception of a rule, or a representation (Vorstellung) of a rule. So, ordinary natural objects act according to rules, the laws of nature, but we act according to representations of rules / to conceptions of rules.</p><p>The explanation as to why I use the word ‘purple’ for purple things, the rule plays a crucial part even if it is not in my head. It is in the teachers’ heads (they’re already in the language and can conceive of rules). So the rule is causally antecedent to my behavior, so I can be following the rule (without regress).</p><p>Related quesiton addressed here: <span class="math inline">\(\ref{phil-situations-section-classical-behaviorism}\)</span></p><p>How is it that I can apply a concept according to norms, to invoke a pre-linguistic awareness of universals, that’s going to be a given. And the key thing is, because that pre-linguistic awareness is conceived of as providing <em>reasons</em> for me to do this. It’s not just that I’ve been <em>trained</em> to respond to some physiological thing by doing it (that would be okay. That could be part of the the real explanation, the pattern governed explanation). It’s that that pre-linguistic awareness provides reasons. And the claim is reasons are always making a move in a game that’s making the inferential move. And the question is: what determines the norms that govern that? Then we’re off on the on the regress, again, so we’ve got to have some story that doesn’t have that form. The form of the argument against the myth of the given. It’s the idea that the awareness that givenness provides something that can serve as a reason, but is itself not dependent on our having learned a language, having a conceptual scheme, and so on.</p><p>To do: understand language entry transitions and language exit transitions.</p><p>There is debate (but it should be more of a bigger deal, in Brandom’s opinion) about what are the minimal features needed for one to have a discursive language practice. Brandom views logical language as optional (though the expressive power would be incredibly stunted, you could still give and ask for reasons). MacDowell and Sellars think otherwise, that there can’t be discourse without a meta-language.</p><p>Sellars needs the notion of language to be something that evolves over time (rather than an instantaneous collection of rules) because we want the decision to make a material move to occur with in a language (one is not doing redescription in another language).</p>
	<script type="text/javascript">
        (function()
        {

            //we'll need the getBoundingClientRect function for the
            //hash scripting, so if it's not supported just return,
            //then the elements will remain in their default open state
            if(typeof(document.createElement('span').getBoundingClientRect) == 'undefined') { return; }


            //add event construct for modern browsers or IE
            //which fires the callback with a pre-converted target reference
            function addEvent(node, type, callback)
            {
                if(node.addEventListener)
                {
                    node.addEventListener(type, function(e)
                    {
                        callback(e, e.target);

                    }, false);
                }
                else if(node.attachEvent)
                {
                    node.attachEvent('on' + type, function(e)
                    {
                        callback(e, e.srcElement);
                    });
                }
            }

            //handle cross-modal click events
            function addClickEvent(node, callback)
            {
                var keydown = false;
                addEvent(node, 'keydown', function()
                {
                    keydown = true;
                });
                addEvent(node, 'keyup', function(e, target)
                {
                    keydown = false;
                    if(e.keyCode == 13) { callback(e, target); }
                });
                addEvent(node, 'click', function(e, target)
                {
                    if(!keydown) { callback(e, target); }
                });
            }

            //get the nearest ancestor element of a node that matches a given tag name
            function getAncestor(node, match)
            {
                do
                {
                    if(!node || node.nodeName.toLowerCase() == match)
                    {
                        break;
                    }
                }
                while(node = node.parentNode);

                return node;
            }



            //create a started flag so we can prevent the initialisation
            //function firing from both DOMContentLoaded and window.onloiad
            var started = false;

            //initialisation function
            function addDetailsOmnifill(list)
            {
                //if this has already happened, just return
                //else set the flag so it doesn't happen again
                if(started)
                {
                    return;
                }
                started = true;

                //get the collection of details elements, but if that's empty
                //then we don't need to bother with the rest of the scripting
                if((list = document.getElementsByTagName('details')).length == 0)
                {
                    return;
                }

                //else iterate through them to apply their initial state
                for(var n = list.length, i = 0; i < n; i ++)
                {
                    var details = list[i];

                    //detect native implementations
                    details.__native = typeof(details.open) == 'boolean';

                    //save shortcuts to the inner summary and content elements
                    details.__summary = details.getElementsByTagName('summary').item(0);
                    details.__content = details.getElementsByTagName('div').item(0);

                    //if the content doesn't have an ID, assign it one now
                    //which we'll need for the summary's aria-controls assignment
                    if(!details.__content.id)
                    {
                        details.__content.id = 'details-content-' + i;
                    }

                    //then define aria-controls on the summary to point to that ID
                    //so that assistive technologies know it controls the aria-expanded state
                    details.__summary.setAttribute('aria-controls', details.__content.id);

                    //also set tabindex so the summary is keyboard accessible
                    details.__summary.setAttribute('tabindex', '0');

                    //then set aria-expanded and style.display and remove the
                    //open attribute, so this region is now collapsed by default
                    details.__content.setAttribute('aria-expanded', 'false');
                    details.__content.style.display = 'none';
                    details.removeAttribute('open');

                    //create a circular reference from the summary back to its
                    //parent details element, for convenience in the click handler
                    details.__summary.__details = details;

                    //then if this is not a native implementation, create a twisty
                    //inside the summary, saving its reference as a summary property
                    if(!details.__native)
                    {
                        var twisty = document.createElement('span');
                        twisty.className = 'twisty';
                        twisty.appendChild(document.createTextNode('\u25ba'));

                        details.__summary.__twisty = details.__summary.insertBefore(twisty, details.__summary.firstChild);
                    }
                }



                //define a statechange function that updates aria-expanded and style.display
                //to either expand or collapse the region (ie. invert the current state)
                //or to set a specific state if the expanded flag is strictly true or false
                //then update the twisty if we have one with a correpsonding glyph
                function statechange(summary, expanded)
                {
                    if(typeof(expanded) == 'undefined')
                    {
                        expanded = summary.__details.__content.getAttribute('aria-expanded') == 'true';
                    }
                    else if(expanded === false)
                    {
                        summary.__details.setAttribute('open', 'open');
                    }
                    else if(expanded === true)
                    {
                        summary.__details.removeAttribute('open');
                    }

                    summary.__details.__content.setAttribute('aria-expanded', (expanded ? 'false' : 'true'));
                    summary.__details.__content.style.display = (expanded ? 'none' : 'block');

                    if(summary.__twisty)
                    {
                        summary.__twisty.firstChild.nodeValue = (expanded ? '\u25ba' : '\u25bc');
                    }

                    return true;
                }

                //now bind a document click event to handle summary elements
                //if the target is not inside a summary element, just return true
                //to pass-through the event, else call and return the statechange function
                //which also returns true to pass-through the remaining event
                addClickEvent(document, function(e, summary)
                {
                    if(!(summary = getAncestor(summary, 'summary')))
                    {
                        return true;
                    }
                    return statechange(summary);
                });



                //define an autostate function that identifies whether a target
                //is or is inside a details region, and if so expand that region
                //then iterate up the DOM expanding any ancestors, then finally
                //return the original target if applicable, or null if not
                function autostate(target, expanded, ancestor)
                {
                    if(typeof(ancestor) == 'undefined')
                    {
                        if(!(target = getAncestor(target, 'details')))
                        {
                            return null;
                        }
                        ancestor = target;
                    }
                    else
                    {
                        if(!(ancestor = getAncestor(ancestor, 'details')))
                        {
                            return target;
                        }
                    }

                    statechange(ancestor.__summary, expanded);

                    return autostate(target, expanded, ancestor.parentNode);
                }

                //then if we have a location hash, call the autostate
                //function now with the target element it refers to
                if(location.hash)
                {
                    autostate(document.getElementById(location.hash.substr(1)), false);
                }

                //then bind a document click event to handle internal page links
                //ignoring links to other pages, else passing the target it
                //refers to to the autostate function, and if that returns a target
                //auto-scroll the page so that the browser jumps to that target
                //then return true anyway so that the address-bar hash updates
                addEvent(document, 'click', function(e, target)
                {
                    if(!target.href)
                    {
                        return true;
                    }
                    if((target = target.href.split('#')).length == 1)
                    {
                        return true;
                    }
                    if(document.location.href.split('#')[0] != target[0])
                    {
                        return true;
                    }
                    if(target = autostate(document.getElementById(target[1]), false))
                    {
                        window.scrollBy(0, target.getBoundingClientRect().top);
                    }
                    return true;
                });
            }

            //then bind two load events for modern and older browsers
            //if the first one fires it will set a flag to block the second one
            //but if it's not supported then the second one will fire
            addEvent(document, 'DOMContentLoaded', addDetailsOmnifill);
            addEvent(window, 'load', addDetailsOmnifill);

        })();
        </script>
 </body></html>