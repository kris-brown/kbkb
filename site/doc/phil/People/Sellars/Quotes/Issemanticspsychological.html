<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8"/>
  <meta content="pandoc" name="generator"/>
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
  <title>Is semantics psychological</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 80em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"/></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

<!-- Summary stuff here -->
<script type="text/javascript">
	(function()
	{
		//basic html5 shim just for the elements we're using
		for(var tags = ['nav','details','summary'], i = 0; i < tags.length; i ++)
		{
			document.createElement(tags[i]);
		}
	})();
	</script>

	<link rel="stylesheet" href="https://web.stanford.edu/~ksb/phil/demo.css" type="text/css" media="screen, projection, print, handheld" />

    <!-- MiniPreview stuff here -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <link href="https://web.stanford.edu/~ksb/phil/jquery.minipreview.css" rel="stylesheet">
    <script src="https://web.stanford.edu/~ksb/phil/jquery.minipreview.js"></script>
    <script>
        $(function() {
          $('a').miniPreview({ prefetch: 'parenthover' }); // ALL links
		  // none, parenthover, or pageload
          //$('#p4 a').miniPreview({ prefetch: 'none' });
        });
    </script>
</head><body><header id="title-block-header">
<h1 class="title">Is semantics psychological</h1>
</header><p><a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Sellars/Quotes/Exemplification.html">Previous</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Sellars/Quotes.html">Up</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Sellars/Quotes/Judgmentintheorderofexplanation.html">Next</a> <a href="https://web.stanford.edu/~ksb/phil/doc/phil/People/Sellars/Quotes/Issemanticspsychological.pdf">PDF</a></p><p>“The means of semantical statements is no more a psychological word than is the ought of ethical statements or the must of modal statements.&#34;</p><p>I think of this in the following way: the <span class="math inline">\(\square\)</span> operator can be applied to statements to make them ‘modal’ (which could be alethic, deontic, or many other things like “Jones thinks that ...&#34;). One such <span class="math inline">\(\square\)</span> is “Semantically, ...” (or, “Literally, ...”). Ordinary statements made in practical life could be interpreted as having an implicit “Pragmatically, ...” (in fact, could we define <em>pragmatics</em> to be that which play this role?)</p>
	<script type="text/javascript">
        (function()
        {

            //we'll need the getBoundingClientRect function for the
            //hash scripting, so if it's not supported just return,
            //then the elements will remain in their default open state
            if(typeof(document.createElement('span').getBoundingClientRect) == 'undefined') { return; }


            //add event construct for modern browsers or IE
            //which fires the callback with a pre-converted target reference
            function addEvent(node, type, callback)
            {
                if(node.addEventListener)
                {
                    node.addEventListener(type, function(e)
                    {
                        callback(e, e.target);

                    }, false);
                }
                else if(node.attachEvent)
                {
                    node.attachEvent('on' + type, function(e)
                    {
                        callback(e, e.srcElement);
                    });
                }
            }

            //handle cross-modal click events
            function addClickEvent(node, callback)
            {
                var keydown = false;
                addEvent(node, 'keydown', function()
                {
                    keydown = true;
                });
                addEvent(node, 'keyup', function(e, target)
                {
                    keydown = false;
                    if(e.keyCode == 13) { callback(e, target); }
                });
                addEvent(node, 'click', function(e, target)
                {
                    if(!keydown) { callback(e, target); }
                });
            }

            //get the nearest ancestor element of a node that matches a given tag name
            function getAncestor(node, match)
            {
                do
                {
                    if(!node || node.nodeName.toLowerCase() == match)
                    {
                        break;
                    }
                }
                while(node = node.parentNode);

                return node;
            }



            //create a started flag so we can prevent the initialisation
            //function firing from both DOMContentLoaded and window.onloiad
            var started = false;

            //initialisation function
            function addDetailsOmnifill(list)
            {
                //if this has already happened, just return
                //else set the flag so it doesn't happen again
                if(started)
                {
                    return;
                }
                started = true;

                //get the collection of details elements, but if that's empty
                //then we don't need to bother with the rest of the scripting
                if((list = document.getElementsByTagName('details')).length == 0)
                {
                    return;
                }

                //else iterate through them to apply their initial state
                for(var n = list.length, i = 0; i < n; i ++)
                {
                    var details = list[i];

                    //detect native implementations
                    details.__native = typeof(details.open) == 'boolean';

                    //save shortcuts to the inner summary and content elements
                    details.__summary = details.getElementsByTagName('summary').item(0);
                    details.__content = details.getElementsByTagName('div').item(0);

                    //if the content doesn't have an ID, assign it one now
                    //which we'll need for the summary's aria-controls assignment
                    if(!details.__content.id)
                    {
                        details.__content.id = 'details-content-' + i;
                    }

                    //then define aria-controls on the summary to point to that ID
                    //so that assistive technologies know it controls the aria-expanded state
                    details.__summary.setAttribute('aria-controls', details.__content.id);

                    //also set tabindex so the summary is keyboard accessible
                    details.__summary.setAttribute('tabindex', '0');

                    //then set aria-expanded and style.display and remove the
                    //open attribute, so this region is now collapsed by default
                    details.__content.setAttribute('aria-expanded', 'false');
                    details.__content.style.display = 'none';
                    details.removeAttribute('open');

                    //create a circular reference from the summary back to its
                    //parent details element, for convenience in the click handler
                    details.__summary.__details = details;

                    //then if this is not a native implementation, create a twisty
                    //inside the summary, saving its reference as a summary property
                    if(!details.__native)
                    {
                        var twisty = document.createElement('span');
                        twisty.className = 'twisty';
                        twisty.appendChild(document.createTextNode('\u25ba'));

                        details.__summary.__twisty = details.__summary.insertBefore(twisty, details.__summary.firstChild);
                    }
                }



                //define a statechange function that updates aria-expanded and style.display
                //to either expand or collapse the region (ie. invert the current state)
                //or to set a specific state if the expanded flag is strictly true or false
                //then update the twisty if we have one with a correpsonding glyph
                function statechange(summary, expanded)
                {
                    if(typeof(expanded) == 'undefined')
                    {
                        expanded = summary.__details.__content.getAttribute('aria-expanded') == 'true';
                    }
                    else if(expanded === false)
                    {
                        summary.__details.setAttribute('open', 'open');
                    }
                    else if(expanded === true)
                    {
                        summary.__details.removeAttribute('open');
                    }

                    summary.__details.__content.setAttribute('aria-expanded', (expanded ? 'false' : 'true'));
                    summary.__details.__content.style.display = (expanded ? 'none' : 'block');

                    if(summary.__twisty)
                    {
                        summary.__twisty.firstChild.nodeValue = (expanded ? '\u25ba' : '\u25bc');
                    }

                    return true;
                }

                //now bind a document click event to handle summary elements
                //if the target is not inside a summary element, just return true
                //to pass-through the event, else call and return the statechange function
                //which also returns true to pass-through the remaining event
                addClickEvent(document, function(e, summary)
                {
                    if(!(summary = getAncestor(summary, 'summary')))
                    {
                        return true;
                    }
                    return statechange(summary);
                });



                //define an autostate function that identifies whether a target
                //is or is inside a details region, and if so expand that region
                //then iterate up the DOM expanding any ancestors, then finally
                //return the original target if applicable, or null if not
                function autostate(target, expanded, ancestor)
                {
                    if(typeof(ancestor) == 'undefined')
                    {
                        if(!(target = getAncestor(target, 'details')))
                        {
                            return null;
                        }
                        ancestor = target;
                    }
                    else
                    {
                        if(!(ancestor = getAncestor(ancestor, 'details')))
                        {
                            return target;
                        }
                    }

                    statechange(ancestor.__summary, expanded);

                    return autostate(target, expanded, ancestor.parentNode);
                }

                //then if we have a location hash, call the autostate
                //function now with the target element it refers to
                if(location.hash)
                {
                    autostate(document.getElementById(location.hash.substr(1)), false);
                }

                //then bind a document click event to handle internal page links
                //ignoring links to other pages, else passing the target it
                //refers to to the autostate function, and if that returns a target
                //auto-scroll the page so that the browser jumps to that target
                //then return true anyway so that the address-bar hash updates
                addEvent(document, 'click', function(e, target)
                {
                    if(!target.href)
                    {
                        return true;
                    }
                    if((target = target.href.split('#')).length == 1)
                    {
                        return true;
                    }
                    if(document.location.href.split('#')[0] != target[0])
                    {
                        return true;
                    }
                    if(target = autostate(document.getElementById(target[1]), false))
                    {
                        window.scrollBy(0, target.getBoundingClientRect().top);
                    }
                    return true;
                });
            }

            //then bind two load events for modern and older browsers
            //if the first one fires it will set a flag to block the second one
            //but if it's not supported then the second one will fire
            addEvent(document, 'DOMContentLoaded', addDetailsOmnifill);
            addEvent(window, 'load', addDetailsOmnifill);

        })();
        </script>
 </body></html>